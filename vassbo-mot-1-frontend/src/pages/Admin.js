// src/pages/Admin.jsimport React, {useState, useContext} from 'react';import {GameContext} from '../context/GameContext';import '../components/Admin.css'; // Ensure this import is presentimport {useNavigate} from "react-router-dom";import {toast, ToastContainer} from 'react-toastify';import 'react-toastify/dist/ReactToastify.css';const Admin = () => {	const {createGame, addQuestion, startGame, games, updateQuestion, setGames} = useContext(GameContext);	const [title, setTitle] = useState('');	const [gameCode, setGameCode] = useState('');	const [question, setQuestion] = useState('');	const [rangeMin, setRangeMin] = useState('');	const [rangeMax, setRangeMax] = useState('');	const [error, setError] = useState('');	const [editError, setEditError] = useState('');	const [successMessage, setSuccessMessage] = useState('');	const [editSuccessMessage, setEditSuccessMessage] = useState('');	const [showQuestions, setShowQuestions] = useState(true);	const [editIndex, setEditIndex] = useState(null);	const [editedQuestion, setEditedQuestion] = useState({text: '', rangeMin: '', rangeMax: ''});	const navigate = useNavigate();	const [showWarning, setShowWarning] = useState(false);	const handleCreateGame = async () => {		if (!title.trim()) {			setError('Konkurransenavn kan ikke være tomt.');			return;		}		try {			const newGame = await createGame(title);			setGameCode(newGame.gameCode);			setTitle('');			setError('');			setSuccessMessage(`Spill "${newGame.title}" opprettet! Spillkoden er ${newGame.gameCode}.`);			const currentGame = games[gameCode];			setGames((prevGames) => ({				...prevGames,				[newGame.gameCode]: newGame,			}));		} catch (err) {			setError('Feil ved opprettelse av spill.');			setSuccessMessage('');		}	};	const handleAddQuestion = async () => {		if (!question.trim()) {			setError('Spørsmål kan ikke være tomt.');			return;		}		const min = Number(rangeMin);		const max = Number(rangeMax);		if (isNaN(min) || isNaN(max) || min >= max) {			setError('Vennligst oppgi gyldig range (min < max).');			return;		}		const newQuestion = {			text: question,			range: [min, max],		};		try {			await addQuestion(gameCode, newQuestion);			setQuestion('');			setRangeMin('');			setRangeMax('');			setError('');			setSuccessMessage('Spørsmål lagt til!');		} catch (err) {			setError('Feil ved tillegg av spørsmål.');			setSuccessMessage('');		}	};	const handleStartGame = async () => {		const currentGame = games[gameCode];		if (!currentGame || currentGame.players.length < 2 || currentGame.questions.length < 1) {			setError('Spillet må ha minst to spillere og ett spørsmål.');			return;		}		try {			await startGame(gameCode);			setError('');			setSuccessMessage('Spillet har startet! Navigerer til spillmodus...');			setTimeout(() => {				navigate(`/admin/flow/${gameCode}`);			}, 1500);		} catch (err) {			setError('Feil ved oppstart av spill.');		}	};	const handleEditQuestion = (index) => {		const currentGame = games[gameCode];		if (!currentGame || !currentGame.questions || !currentGame.questions[index]) {			setEditError('Spørsmålet ble ikke funnet.');			return;		}		const questionToEdit = currentGame.questions[index];		setEditIndex(index);		setEditedQuestion({			text: questionToEdit.text,			rangeMin: questionToEdit.range[0],			rangeMax: questionToEdit.range[1],		});	};	const handleSaveEditedQuestion = async () => {		if (!editedQuestion.text.trim()) {			setEditError('Spørsmål kan ikke være tomt.');			return;		}		const min = Number(editedQuestion.rangeMin);		const max = Number(editedQuestion.rangeMax);		if (isNaN(min) || isNaN(max) || min >= max) {			setEditError('Vennligst oppgi gyldig range (min < max).');			return;		}		const updatedQuestion = {			text: editedQuestion.text,			range: [min, max],		};		try {			const response = await updateQuestion(gameCode, editIndex, updatedQuestion);			setGames((prevGames) => {				const updatedGames = {...prevGames};				updatedGames[gameCode].questions[editIndex] = response.question;				return updatedGames;			});			setEditIndex(null);			setEditedQuestion({text: '', rangeMin: '', rangeMax: ''});			setEditError('');			setEditSuccessMessage('Spørsmål oppdatert!');			toast.success('Spørsmål oppdatert!');		} catch (err) {			toast.error('Feil ved oppdatering av spørsmål.');			setEditSuccessMessage('');		}	};	const currentGame = games[gameCode];	return (		<div className="admin-container">			<h2 className="admin-title">Admin Dashboard</h2>			<div className="create-game-section">				{!gameCode ? (					<>						<input							type="text"							placeholder="Konkurransenavn"							value={title}							onChange={(e) => setTitle(e.target.value)}							className="admin-input"						/>						<button onClick={handleCreateGame} className="create-button">Opprett Spill</button>					</>				) : (					currentGame ? (						<div className="game-details">							<h3 className="game-name">{currentGame.title}</h3>							<p className="game-code"><strong>Spillkode:</strong> {gameCode}</p>						</div>					) : (						<p className="loading-message"><strong>Spillnavn:</strong> Laster...</p>					)				)}			</div>			{/* Questions Section */}			{gameCode && currentGame && currentGame.questions && (				<div className="questions-section">					<h3 className="section-title">Spørsmål ({currentGame.questions.length})</h3>					<button onClick={() => setShowQuestions((prev) => !prev)} className="toggle-questions-button">						{showQuestions ? 'Skjul Spørsmål' : 'Vis Spørsmål'}					</button>					{showQuestions && (						<div className="questions-content">							{/* Questions List */}							<ul className="questions-list">								{currentGame.questions.map((q, index) => (									<li key={index} className="question-item">										{editIndex === index ? (											<div className="edit-question">												<input													type="text"													value={editedQuestion.text}													onChange={(e) =>														setEditedQuestion({															...editedQuestion,															text: e.target.value														})													}													placeholder="Oppdatert spørsmålstekst"													className="edit-input"												/>												<div className="range-inputs">													<input														type="number"														value={editedQuestion.rangeMin}														onChange={(e) =>															setEditedQuestion({																...editedQuestion,																rangeMin: e.target.value															})														}														placeholder="Min verdi"														className="range-input"													/>													<input														type="number"														value={editedQuestion.rangeMax}														onChange={(e) =>															setEditedQuestion({																...editedQuestion,																rangeMax: e.target.value															})														}														placeholder="Max verdi"														className="range-input"													/>												</div>												<div class="button-container">													<button onClick={handleSaveEditedQuestion} className="save-button">Lagre</button>													<button onClick={() => setEditIndex(null)} className="cancel-button">Avbryt</button>													{editError && <p className="edit-error-message">{editError}</p>}												</div>											</div>										) : (											<div className="question-item-content">												<span													className="question-text">{q.text} {q.range ? `(${q.range[0]} - ${q.range[1]})` : ''}</span>												<button onClick={() => handleEditQuestion(index)} className="edit-button">Rediger</button>											</div>										)}									</li>								))}								{editSuccessMessage && <p className="edit-success-message">{editSuccessMessage}</p>}							</ul>							{/* Add Question Section */}							<div className="add-question-section">								<h4 className="add-question-title">Legg til Spørsmål</h4>								<input									type="text"									placeholder="Spørsmål"									value={question}									onChange={(e) => setQuestion(e.target.value)}									className="add-question-input"								/>								<div className="range-inputs">									<input										type="number"										placeholder="Min verdi"										value={rangeMin}										onChange={(e) => setRangeMin(e.target.value)}										className="range-input"									/>									<input										type="number"										placeholder="Max verdi"										value={rangeMax}										onChange={(e) => setRangeMax(e.target.value)}										className="range-input"									/>								</div>								<button onClick={handleAddQuestion} className="add-question-button">Legg til Spørsmål</button>							</div>						</div>					)}				</div>			)}			{currentGame && currentGame.players && (				<div className="players-section">					<h3 className="section-title">Spillere ({currentGame.players.length})</h3>					{currentGame.players.length === 0 ? (						<p className="no-players-message">Ingen spillere har blitt med enda.</p>					) : (						<ul className="players-list">							{currentGame.players.map((player, index) => (								<li key={index} className="player-item">									{player.name}								</li>							))}						</ul>					)}				</div>			)}			{gameCode && currentGame && (				<div className="start-game-section">					<h3 className="section-title">Start Spill</h3>					<div						className="start-game-wrapper"						onMouseEnter={() => {							if (currentGame.players.length < 2 || currentGame.questions.length < 1) {								setShowWarning(true); // Show warning on hover							}						}}						onMouseLeave={() => setShowWarning(false)} // Hide warning when mouse leaves					>						<button							onClick={(e) => {								if (currentGame.players.length < 2 || currentGame.questions.length < 1) {									e.preventDefault();									setShowWarning(true); // Show warning on click								} else {									handleStartGame();								}							}}							disabled={currentGame.players.length < 2 || currentGame.questions.length < 1}							className="start-game-button"						>							Start Spill						</button>					</div>					{showWarning && (						<p className="warning-message">Minst to spillere må bli med før spillet kan startes.</p>					)}				</div>			)}			{/*{successMessage && <p className="success-message">{successMessage}</p>}			{error && <p className="success-message">{successMessage}</p>}*/}			<ToastContainer/>		</div>	);};export default Admin;